#' @name importEvents
#' @title Import Events To or Rename Events In a Project
#' 
#' @description This method allows you to import Events into a project or to 
#'   update existing Events' attributes, such as the event name, days offset, 
#'   etc. The unique event name of an Event cannot be changed because it is 
#'   auto-generated by REDCap. To use this method, you must have API 
#'   Import/Update privileges AND Project Design/Setup privileges in the project.
#'   
#' @param rcon A REDCap connection object as generated by 
#'   \code{redcapConnection}.
#' @param events \code{data.frame} with at least two columns for 
#'   \code{arm_num} and \code{event_name}. 
#' @param arm_num \code{character(1)} The name of the column in \code{events}
#'   with the arm number.
#' @param event_name \code{character(1)} The name of the column in \code{events} 
#'   with the event name.
#' @param other_cols named \code{character} vector. The name of the element
#'   will be a property recognized by the API, such as \code{unique_event_name}, 
#'   \code{day_offset}, \code{offset_min}, or \code{offset_max}. Note: the names
#'   are not validated--this will allow the function to work correctly if 
#'   additional properties are added to the API in the future.  See Details
#'   for more information about validations on properties known to be 
#'   accepted in the API.
#' @param override \code{logical(1)}. When \code{FALSE}, you may only add new 
#'   or rename existing events. When \code{TRUE}, a full overwrite is done, which 
#'   will delete all events and replace them with the designations in the 
#'   \code{events} argument.
#' @param error_handling An option for how to handle errors returned by the API.
#'   see \code{\link{redcapError}}
#' @param config \code{list} Additional configuration parameters to pass to 
#'   \code{\link[httr]{POST}}. These are appended to any parameters in 
#'   \code{rcon$config}.
#' @param api_param \code{list} Additional API parameters to pass into the
#'   body of the API call. This provides users to execute calls with options
#'   that may not otherwise be supported by \code{redcapAPI}.
#'   
#' @details 
#' The column representing the arm number must be either \code{character} 
#' or \code{numeric}. If it is a \code{character}, it will be coerced to 
#' a \code{numeric}. Before the import, the contents are tested and must be
#' \code{integerish}.
#' 
#' The column representing the event name must be atomic. It will be converted 
#' to a \code{character} before the import.
#' 
#' If \code{unique_event_name} is prescribed in \code{other_cols}, it must
#' be either \code{character} or \code{numeric}.
#' 
#' If any of \code{day_offset}, \code{offset_min}, or \code{offset_max} are
#' prescribed in \code{other_cols}, they must be either \code{character} 
#' or \code{integerish}. If they are \code{character}, it will be coerced to 
#' a \code{integerish}. 
#' 
#' @section REDCap API Documentation:
#' This method allows you to import Events into a project or to update 
#'   existing Events' attributes, such as the event name, days offset, etc. 
#'   The unique event name of an Event cannot be changed because it is 
#'   auto-generated by REDCap. Please note that the only way to update an 
#'   existing Event is to provide the unique_event_name attribute, and if 
#'   the \code{unique_event_name} attribute is missing for an Event being 
#'   imported (when \code{override = FALSE}), it will assume it to be a 
#'   new Event that should be created. Notice: Because of the \code{override} 
#'   parameter's destructive nature, this method may only use 
#'   \code{override = TRUE} for projects in Development status.
#' 
#' NOTE: This only works for longitudinal projects.
#' 
#' @section REDCap Version:
#' At least 8.1.17+ (and likely some earlier versions)
#' 
#' @return 
#' None.
#' 
#' @references
#' Please refer to your institution's API documentation.
#' 
#' @export

importEvents <- function(rcon, 
                       events, 
                       arm_num = "arm_num", 
                       event_name = "event_name", 
                       other_cols = character(0),
                       override = FALSE, 
                       error_handling = getOption("redcap_error_handling", "error"), 
                       config = list(), 
                       api_param = list()){
  
  KNOWN_PROPERTY <- c("day_offset", "Offset_min", "Offset_max")
  
  coll <- checkmate::makeAssertCollection()
  
  checkmate::assert_class(x = rcon, 
                          classes = "redcapApiConnection", 
                          add = coll)
  
  checkmate::assert_data_frame(x = events, 
                               add = coll)
  
  checkmate::assert_character(x = arm_num, 
                              len = 1, 
                              add = coll)
  
  checkmate::assert_character(x = event_name, 
                              len = 1, 
                              add = coll)
  
  checkmate::assert_character(x = other_cols, 
                              names = "named", 
                              add = coll)
  
  checkmate::assert_logical(x = override, 
                            len = 1, 
                            add = coll)
  
  error_handling <- checkmate::matchArg(x = error_handling, 
                                        choices = c("null", "error"),
                                        add = coll)
  
  checkmate::assert_list(x = config,
                         names = "named",
                         add = coll)
  
  checkmate::assert_list(x = api_param, 
                         names = "named",
                         add = coll)
  
  checkmate::reportAssertions(coll)
  
  checkmate::assert_subset(x = c(arm_num, event_name, other_cols), 
                           choices = names(events), 
                           add = coll)
  
  checkmate::reportAssertions(coll)
  
  data <- events[c(event_name, arm_num, other_cols)]
  
  if (!checkmate::test_integerish(x = data[[arm_num]]) &&
      !checkmate::test_character(x = data[[arm_num]])){
    coll$push(sprintf("`events$%s` must be either a `character(1)` or `integerish(1)`", 
                      arm_num))
  }
  
  checkmate::assert_atomic(x = data[[event_name]], 
                           add = coll)
  
  if ("unique_event_name" %in% names(other_cols)){
    uen <- other_cols["unique_event_name"]
    if (!checkmate::test_integerish(x = data[[uen]]) &&
        !checkmate::test_character(x = data[[uen]])){
      coll$push(sprintf("`events$%s` must be either a `character(1)` or `integerish(1)`", 
                        uen))
    }
  }
  
  for (p in KNOWN_PROPERTY){
    this_property <- other_cols[p]
    if (this_property %in% names(other_cols)){
      if (!checkmate::test_integerish(x = data[[this_property]]) &&
          !checkmate::test_character(x = data[[this_property]])){
        coll$push(sprintf("`events$%s` must be either a `character(1)` or `integerish(1)`", 
                          this_property))
      }
    }
  }
  
  checkmate::reportAssertions(coll)
  
  data[[arm_num]] <- as.numeric(data[[arm_num]])
  data[[event_name]] <- as.character(data[[event_name]])
  
  if ("unique_event_name" %in% names(other_cols)){
    data[[other_cols["unique_event_name"]]] <- 
      as.character(data[[other_cols["unique_event_name"]]])
  }
  
  for (p in KNOWN_PROPERTY){
    if (p %in% names(other_cols)){
      this_property <- other_cols[p]
      data[[p]] <- as.numeric(data[[this_property]])
      
      checkmate::assert_integerish(x = data[[this_property]], 
                                   add = coll, 
                                   .var.name = this_property)
    }
  }
  
  checkmate::reportAssertions(coll)
  
  data <- dataFrameToString(data)
  
  body <- list(content = "event",
               action = "import", 
               override = as.character(as.numeric(override)), 
               data = data, 
               format = "csv")

  response <- makeApiCall(rcon, 
                          body = c(body, api_param), 
                          config = config)
  
  redcapError(response, error_handling = error_handling)
  
  if (response$status_code == 200){
    as.numeric(as.character(response))
  }
  
}

#' @rdname importEvents
#' @export

import_events <- importEvents