#' @name importFiles
#' @title Imports a File to REDCap to Attach to a Record
#' 
#' @description A single file may be attached to a single record.  The 
#'   behavior of this function is consistent with the
#'   behavior of the API, which only allows one file to be uploaded at a time
#'   
#' @param rcon A REDCap connection object as generated by \code{redcapConnection}
#' @param file \code{character(1)} giving the file path to the file to be imported.
#' @param record \code{integerish(1)} The record ID in which the desired file 
#'   is to be stored.
#' @param field \code{character(1)} The field name in which the file is stored. 
#' @param event \code{character(1)} The event name for the file to be stored in.
#'   This applies only to longitudinal projects.  If the event is not supplied  
#'   for a longitudinal project, the API will return an error
#' @param overwrite \code{logical(1)} When \code{FALSE}, the function checks if a 
#'   file already exists for that record.  If a file exists, the function 
#'   terminates to prevent overwriting.  When \code{TRUE}, no additional 
#'   check is performed.
#' @param bundle A \code{redcapBundle} object as created by \code{exportBundle}.
#'   This exists mostly for backward compatibility.
#' @param repeat_instance \code{integerish(1)} The repeat instance number of the repeating
#'   event or the repeating instrument. When available in your instance
#'   of REDCap, and passed as NULL, the API will assume a value of 1.
#' @param error_handling An option for how to handle errors returned by the API.
#'   see \code{\link{redcap_error}}
#' @param config \code{list} Additional configuration parameters to pass to 
#'   \code{\link[httr]{POST}}. These are appended to any parameters in 
#'   \code{rcon$config}.
#' @param api_param \code{list} Additional API parameters to pass into the
#'   body of the API call. This provides users to execute calls with options
#'   that may not otherwise be supported by \code{redcapAPI}.
#' 
#' @details The function may only import a single file
#' 
#' @author Benjamin Nutter
#' 
#' @export

importFiles <- function(rcon, 
                        file, 
                        record, 
                        field, 
                        event = character(0), 
                        overwrite = TRUE, 
                        repeat_instance = 1, 
                        bundle = getOption("redcap_bundle"),
                        error_handling = getOption("redcap_error_handling", "error"), 
                        config = list(), 
                        api_param = list()){
  
  coll <- checkmate::makeAssertCollection()
  
  checkmate::assert_class(x = rcon, 
                          classes = "redcapApiConnection", 
                          add = coll)
  
  checkmate::assert_file_exists(x = file, 
                                add = coll)
  
  checkmate::assert_integerish(x = record, 
                               len = 1, 
                               add = coll)
  
  checkmate::assert_character(x = field, 
                              len = 1, 
                              add = coll)
  
  checkmate::assert_character(x = event, 
                              max.len = 1, 
                              add = coll)
  
  checkmate::assert_logical(x = overwrite, 
                            len = 1, 
                            add = coll)
  
  checkmate::assert_integerish(x = repeat_instance, 
                               len = 1, 
                               add = coll)
  
  error_handling <- checkmate::matchArg(x = error_handling, 
                                        choices = c("null", "error"), 
                                        add = coll)
  
  checkmate::assert_list(x = config, 
                         add = coll)
  
  checkmate::assert_list(x = api_param, 
                         add = coll)
  
  checkmate::reportAssertions(coll)
  
  if (is.numeric(record)) record <- as.character(record)
  

  #* make sure 'field' exist in the project and are 'file' fields
  if (is.null(bundle$meta_data)){ 
    meta_data <- exportMetaData(rcon)
  } else {
    meta_data <- bundle$meta_data
  }
  
  if (!field %in% meta_data$field_name) 
    coll$push(paste("'", field, "' does not exist in the project.", sep=""))
  
  if (meta_data$field_type[meta_data$field_name == field] != "file")
    coll$push(paste0("'", field, "' is not of field type 'file'"))
  
  #* make sure 'event' exists in the project
  if (is.null(bundle$events)){ 
    events_list <- exportEvents(rcon)
  } else {
    events_list <- bundle$events
  }
  
  if (class(events_list) == 'data.frame'){
    if (!event %in% events_list$unique_event_name) 
      coll$push(paste0("'", event, "' is not a valid event name in this project."))
  }
  
  if (!overwrite){
    fileThere <- exportRecords(rcon, 
                               records = record, 
                               fields = field, 
                               events = event)
    if (!is.na(fileThere[field])) 
      coll$push("A file already exists for this record and overwrite = FALSE")
  }
  
  checkmate::reportAssertions(coll)
  
  body <- list(content = "file",
               action = "import", 
               record = as.character(record),
               field = field, 
               file = httr::upload_file(file), 
               returnFormat = "csv")
  
  if (!is.null(event)){
    body[["event"]] <- event
  } 
  
  if (!is.null(repeat_instance)){
    body[["repeat_instance"]] <- as.character(repeat_instance)
  }

  response <- makeApiCall(rcon, 
                          body = c(body, api_param), 
                          config = config)
  
  redcapError(response, error_handling = error_handling)
  
  if (response$status_code == 200){
    as.character(response)
    # message("The file was successfully uploaded")
  } else {
    redcap_error(file, error_handling)
  }
}
  


#' @rdname importFiles
#' @export

import_files <- importFiles